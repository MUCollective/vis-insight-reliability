---
title: "Data generation"
author: "Xiaoying Pu"
date: "2/11/2019"
output: html_document
---

```{r setup, include=FALSE}
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(modelr)
library(reshape2)
library(poweRlaw) # powercurve?
library(MASS) # multivariate Gaussian
library(gganimate)
library(ggbeeswarm)
library(magrittr)
library(gifski)
library(brms)
library(tidybayes)
library(emmeans)
library(ggstance)
library(transformr) 

```


# Set up dataframe 


```{r}
n_obs <- 100
trial_n <- 1
```

```{r}
gen_fig_name <- function(task_cond, technique_cond, data_cond, trial_n){
   paste0(paste(c(task_cond, technique_cond, data_cond, trial_n), collapse = "_"), ".png")
}
```


# Build dataframes

- Profit (dollars, integer)
  - Gaussians with different means and standard deviations
- Region (categorical)
  - A, B, etc
- Time to ship (days, integer)

`var_names <- c("region", "profit", "ship_time")`


- Comparison: HDI range? 
- Correlation: $r$
- outlier: measure = ?? TODO


# Comparison

```{r}
task_cond <- "COM"
```


Two independent normals

- params:
  - mean of A, sd of A,
  - mean of B, sd of B,
- conditions (all equal variance)
  1. Mean of B greater than A
  2. Mean of B smaller than A
  3. Egal


```{r}
data_cond <- c("1")

nparams <- switch(data_cond,
  "1" = data.frame(means = c(rep(2, n_obs), rep(2.2, n_obs)), sd = c(.2)),
  "2" = data.frame(means = c(rep(2.2, n_obs), rep(2, n_obs)), sd = c(.2)),
  "3" = data.frame(means = c(rep(2, n_obs), rep(2, n_obs)), sd = c(.2))
)

normal_df <- rnorm(n = nparams$means, mean = nparams$means, sd = nparams$sd) %>%
  matrix(ncol = 2) %>%
  as.data.frame() %>%
  rename(normal_1 = "V1", normal_2 = "V2")
```


## Baseline

```{r}
technique_cond <- "BAS"
```


```{r}
sample_n <- 10
sampled_fn <- function(v) sample(x = v, size = sample_n ) 
sampled_normal <- as.data.frame(sapply(normal_df, sampled_fn))
names(sampled_normal) <- c("A", "B")
sampled_normal %<>% melt(
  variable.name = "region", value.name = "profit"
)
```


```{r}
fig_fname <- gen_fig_name(task_cond, technique_cond, data_cond, trial_n)

ggplot(sampled_normal, aes(x = region, y = profit)) + 
  # geom_violin() + 
  geom_quasirandom() +
  # geom_pointrange(data = stat_df, mapping = aes(x= region, y = mean, ymin=low, ymax = high)) + 
  NULL
```

## Error bars

```{r}
technique_cond <- "BAR"
```


calculate interval

```{r}
se_fn <- function(x) 1.96 * (sd(x, na.rm = TRUE)/sqrt(length(x)))
stat_df <- sampled_normal %>%
  group_by(region) %>%
  summarize_all(funs(mean, se_fn)) %>%
  ungroup() %>%
  mutate(low = mean - se_fn) %>%
  mutate(high = mean + se_fn) 

```


```{r}
fig_fname <- gen_fig_name(task_cond, technique_cond, data_cond, trial_n)


ggplot(sampled_normal, aes(x = region, y = profit)) + 
  geom_violin() + 
  # geom_quasirandom() + 
  geom_pointrange(data = stat_df, mapping = aes(x= region, y = mean, ymin=low, ymax = high)) + 
  NULL
```

## HOPS

```{r}
technique_cond <- "HOP"
```


```{r}
n_samples <- 4

sample_normal_boots <- data.frame(matrix(nrow = 0, ncol = 3)) # bivariate + sample No.
for (i in seq_len(n_samples)){
  hops <- as.data.frame(sapply(normal_df, sampled_fn))
  names(hops) <- c("A", "B")
  hops %<>% melt(
  variable.name = "region", value.name = "profit"
  )
  hops$sample <- i 
  sample_normal_boots <- rbind(sample_normal_boots, hops)
}


```


```{r}
fig_fname <- paste0(paste(c(task_cond, technique_cond, trial_n), collapse = "_"), ".png")

ggplot(sample_normal_boots) +
  geom_quasirandom(aes(region, profit))  +
  transition_time(sample)
```

## Superimposed ensembles

Also displaying bootstrapped error bars

```{r}
stat_boots <- sample_normal_boots %>%
  group_by(sample, region) %>%
  summarize_all(funs(mean, se_fn)) %>%
  ungroup() %>%
  mutate(low = mean - se_fn) %>%
  mutate(high = mean + se_fn) 

```

Beam me up, Scotty

```{r}
technique_cond <- "SIE"
fig_fname <- paste0(paste(c(task_cond, technique_cond, trial_n), collapse = "_"), ".png")

ggplot(sample_normal_boots, aes(x = region, y = profit)) + 
   geom_pointrange(data = stat_boots, mapping = aes(x= region, y = mean, ymin=low, ymax = high, color = factor(sample)), position = "jitter") +
 # geom_violin() + 
  geom_quasirandom(aes(color = factor(sample))) +
  NULL
```

## Juxtaposed ensembles

```{r}
technique_cond <- "JXE"
```

```{r}
fig_fname <- paste0(paste(c(task_cond, technique_cond, trial_n), collapse = "_"), ".png")

ggplot(sample_normal_boots) + 
  geom_quasirandom(aes(region, profit)) + facet_grid(.~sample)
```

## Transparent regularization

Linear model

```{r}
unregularized_m <- brm(profit ~ region, data = sampled_normal,
         control = list(adapt_delta = .99),
         save_model = "unregularized")
```

Inspect model

```{r}
summary(unregularized_m)

A <- unregularized_m %>%
  spread_draws(b_Intercept) %>%
  mean_qi() %>%
  mutate("region" = "A") 

B <- unregularized_m %>%
  spread_draws(b_regionB, b_Intercept) %>%
  mean_qi(b_Intercept = b_regionB + b_Intercept) %>%
  mutate("region" = "B")

unregularized_df <- rbind(A, B) %>%
  rename(condition_mean = "b_Intercept") %>%
  add_column(model = "unregularized")

```


```{r}
unregularized_df %>%   
  ggplot(aes(y = condition_mean, 
             x = region, ymin = .lower, ymax = .upper)) +
  geom_pointrange()
```


Regularized model

```{r}
sampled_normal$profit <- sampled_normal$profit

regularized_m <- brm(profit ~ 0 + intercept + region, 
                     data = sampled_normal,
                     control = list(adapt_delta = .99),
                     prior = set_prior("horseshoe(2.1)", class = "b"))
```

```{r}
summary(regularized_m)

A_reg <- regularized_m %>%
  spread_draws(b_intercept) %>%
  mean_qi() %>%
  mutate("region" = "A") 

B_reg <- regularized_m %>%
  spread_draws(b_regionB, b_intercept) %>%
  mean_qi(b_intercept = b_regionB + b_intercept ) %>%
  mutate("region" = "B")

regularized_df <- rbind(A_reg, B_reg) %>%
  rename(condition_mean = "b_intercept") %>%
  add_column(model = "regularized") %>%
  mutate(condition_mean = condition_mean) %>%
  mutate(.lower = .lower) %>%
  mutate(.upper = .upper )




model_df <- rbind(unregularized_df, regularized_df)
```


```{r}
model_df %>%   
  ggplot(aes(y = condition_mean, 
             x = region, ymin = .lower, ymax = .upper, color = model)) +
  geom_pointrange()

```

Change original data

```{r}

A_shift <- model_df$condition_mean[1] - model_df$condition_mean[3]

B_shift <- model_df$condition_mean[2] - model_df$condition_mean[4]

regularized_sampled_normal <- 
  sampled_normal %>% 
  mutate(profit = ifelse(region == "A", profit - A_shift, profit - B_shift))

```

```{r}
reg_and_unreg <-dplyr::bind_rows(
  list(unregularized=sampled_normal,
       regularized=regularized_sampled_normal), .id = 'source')

reg_and_unreg %>%
  ggplot(aes(x = region, y = profit, color = source)) + 
  geom_point() + 
  geom_pointrange(data = model_df, 
                  mapping = aes(y = condition_mean, 
             x = region, ymin = .lower, ymax = .upper, color = model), position = 
               position_nudge(x = 0.1))
```

## Opaque regularization


```{r}
reg_and_unreg %>%
  filter(source == "regularized") %>%
  ggplot(aes(x = region, y = profit, color = source)) + 
  geom_point() + 
  geom_pointrange(data = model_df[model_df$model == "regularized",], 
                  mapping = aes(y = condition_mean, 
             x = region, ymin = .lower, ymax = .upper, color = model), position = 
               position_nudge(x = 0.1))
```




## Beneficial distortion

Zu tun




# Correlation

Multivar gaussian

https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/mvrnorm.html

1. positive correlation 
2. negative correlation
3. no correlation

```{r}
data_cond <- "1"

sigma <- switch(data_cond,
                "1" = matrix(c(10,3,3,2),2,2),
                "2" = matrix(c(10,-3,3,2),2,2),
                "3" = matrix(c(10,0 ,0,2),2,2))


mvn_df <- data.frame(mvrnorm(n = n_obs, c(2, 10), sigma))
names(mvn_df) <- c("profit", "time")
mvn_df$profit <- mvn_df$profit 

```


## Baseline

```{r}
ggplot(mvn_df) + geom_point(aes(profit, time))
```



TODO: transform one variable to uniform or something

- calculate $\mu$ and $\sigma$ for the marginal Gaussian
- get quantiles 
- get X values from another CDF with the quantiles 


## "Error bar"/prob bands

```{r}
m_corr <- brm(time ~ profit, data = mvn_df)
```


```{r}
summary(m_corr)

corr_fits <- mvn_df %>%
  data_grid(profit = seq_range(profit, n = 21)) %>%
  add_fitted_draws(m_corr)
```

posterior fit prob bands

```{r}
corr_fits %>%
  ggplot(aes(profit, time)) +
  stat_lineribbon(aes(y = .value)) +
  geom_point(data = mvn_df, mapping = aes(profit, time)) +
  scale_fill_brewer()

```

or just `lm`?

```{r}
ggplot(mvn_df, aes(profit, time)) + 
  geom_point() + 
  geom_smooth(method = lm)
```

## HOPs

```{r}
corr_fits %>%
  ggplot(aes(profit, time)) + 
  geom_line(aes(y = .value, group = .draw)) + 
  geom_point(data = mvn_samples_df) +
  scale_color_brewer(palette = "Dark2") + 
  transition_states(.draw, 0,1) +
  shadow_mark(future = TRUE, color = "gray50", alpha = 1/20) 

# ndraws = 50
# animate(p, nframes = ndraws, fps = 2.5, width = 576, height = 384, res = 96, type = "cairo")

```






## Superimposed ensemble

```{r}
n_ensemble_members <- 4
member_size <- 20

mvn_samples_df <- data.frame(matrix(nrow = 0, ncol = 3)) # bivariate + sample No.
for (i in seq_len(n_ensemble_members)){
  a_member <- mvn_df %>%
    sample_n(member_size)
  a_member$sample <- i 
  mvn_samples_df <- rbind(mvn_samples_df, a_member)
}
```

oops

```{r}
ggplot(mvn_samples_df,
       aes(profit, time)) +
  geom_point(aes(color = factor(sample))) +
  geom_smooth(method = "lm", aes(fill = factor(sample)))
```

## Juxtaposed ensemble

```{r}
ggplot(mvn_samples_df,
       aes(profit, time)) +
  geom_point(aes(color = factor(sample))) +
  geom_smooth(method = "lm", aes(fill = factor(sample))) +
  facet_wrap(.~sample)
```

