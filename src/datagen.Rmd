---
title: "Data generation"
author: "Xiaoying Pu"
date: "2/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(reshape2)
library(poweRlaw) # powercurve?
library(MASS) # multivariate Gaussian
library(gganimate)
library(ggbeeswarm)
library(magrittr)
library(gifski)
library(brms)
library(tidybayes)
library(emmeans)
library(ggstance)

```


# Set up dataframe 


```{r}
n_obs <- 100
trial_n <- 1

# n_vars <- length(var_names)
```



# Build dataframes

- Profit (dollars, integer)
  - Gaussians with different means and standard deviations
- Region (categorical)
  - A, B, etc
- Time to ship (days, integer)



```{r}
var_names <- c("region", "profit", "ship_time")
```


- Comparison: HDI range? 
- Correlation: $r$
- outlier: measure = ?? TODO


# Comparison

```{r}
task_cond <- "COM"
```


Two independent normals

```{r}
normal_1 <- rnorm(n = n_obs, mean = 2, sd = .2) 
normal_2 <- rnorm(n = n_obs, mean = 2.2, sd = .2)
normal_df <- data_frame(normal_1, normal_2)
```


## Baseline

```{r}
technique_cond <- "BAS"
```


```{r}
sample_n <- 10
sampled_fn <- function(v) sample(x = v, size = sample_n ) 
sampled_normal <- as.data.frame(sapply(normal_df, sampled_fn))
names(sampled_normal) <- c("A", "B")
sampled_normal %<>% melt(
  variable.name = "region", value.name = "profit"
)
```


```{r}
fig_fname <- paste0(paste(c(task_cond, technique_cond, trial_n), collapse = "_"), ".png")

ggplot(sampled_normal, aes(x = region, y = profit)) + 
  # geom_violin() + 
  geom_quasirandom() +
  # geom_pointrange(data = stat_df, mapping = aes(x= region, y = mean, ymin=low, ymax = high)) + 
  NULL
```

## Error bars

```{r}
technique_cond <- "BAR"
```


calculate interval

```{r}
se_fn <- function(x) 1.96 * (sd(x, na.rm = TRUE)/sqrt(length(x)))
stat_df <- sampled_normal %>%
  group_by(region) %>%
  summarize_all(funs(mean, se_fn)) %>%
  ungroup() %>%
  mutate(low = mean - se_fn) %>%
  mutate(high = mean + se_fn) 

```


```{r}
fig_fname <- paste0(paste(c(task_cond, technique_cond, trial_n), collapse = "_"), ".png")

ggplot(sampled_normal, aes(x = region, y = profit)) + 
  geom_violin() + 
  # geom_quasirandom() + 
  geom_pointrange(data = stat_df, mapping = aes(x= region, y = mean, ymin=low, ymax = high)) + 
  NULL
```

## HOPS

```{r}
technique_cond <- "HOP"
```


```{r}
n_samples <- 4

sample_normal_boots <- data.frame(matrix(nrow = 0, ncol = 3)) # bivariate + sample No.
for (i in seq_len(n_samples)){
  hops <- as.data.frame(sapply(normal_df, sampled_fn))
  names(hops) <- c("A", "B")
  hops %<>% melt(
  variable.name = "region", value.name = "profit"
  )
  hops$sample <- i 
  sample_normal_boots <- rbind(sample_normal_boots, hops)
}


```


```{r}
fig_fname <- paste0(paste(c(task_cond, technique_cond, trial_n), collapse = "_"), ".png")

ggplot(sample_normal_boots) +
  geom_quasirandom(aes(region, profit))  +
  transition_time(sample)
```

## Superimposed ensembles

Also displaying bootstrapped error bars

```{r}
stat_boots <- sample_normal_boots %>%
  group_by(sample, region) %>%
  summarize_all(funs(mean, se_fn)) %>%
  ungroup() %>%
  mutate(low = mean - se_fn) %>%
  mutate(high = mean + se_fn) 

```

Beam me up, Scotty

```{r}
technique_cond <- "SIE"
fig_fname <- paste0(paste(c(task_cond, technique_cond, trial_n), collapse = "_"), ".png")

ggplot(sample_normal_boots, aes(x = region, y = profit)) + 
   geom_pointrange(data = stat_boots, mapping = aes(x= region, y = mean, ymin=low, ymax = high, color = factor(sample)), position = "jitter") +
 # geom_violin() + 
  geom_quasirandom(aes(color = factor(sample))) +
  NULL
```

## Juxtaposed ensembles

```{r}
technique_cond <- "JXE"
```

```{r}
fig_fname <- paste0(paste(c(task_cond, technique_cond, trial_n), collapse = "_"), ".png")

ggplot(sample_normal_boots) + 
  geom_quasirandom(aes(region, profit)) + facet_grid(.~sample)
```

## Transparent regularization

Linear model

```{r}
unregularized_m <- brm(profit ~ region, data = sampled_normal,
         control = list(adapt_delta = .99),
         save_model = "unregularized")
```

Inspect model

```{r}
summary(unregularized_m)

A <- unregularized_m %>%
  spread_draws(b_Intercept) %>%
  mean_qi() %>%
  mutate("region" = "A") 

B <- unregularized_m %>%
  spread_draws(b_regionB, b_Intercept) %>%
  mean_qi(b_Intercept = b_regionB + b_Intercept) %>%
  mutate("region" = "B")

unregularized_df <- rbind(A, B) %>%
  rename(condition_mean = "b_Intercept") %>%
  add_column(model = "unregularized")

```


```{r}
unregularized_df %>%   
  ggplot(aes(y = condition_mean, 
             x = region, ymin = .lower, ymax = .upper)) +
  geom_pointrange()
```


Regularized model

```{r}
sampled_normal$profit <- sampled_normal$profit

regularized_m <- brm(profit ~ 0 + intercept + region, 
                     data = sampled_normal,
                     control = list(adapt_delta = .99),
                     prior = set_prior("horseshoe(2.1)", class = "b"))
```

```{r}
summary(regularized_m)

A_reg <- regularized_m %>%
  spread_draws(b_intercept) %>%
  mean_qi() %>%
  mutate("region" = "A") 

B_reg <- regularized_m %>%
  spread_draws(b_regionB, b_intercept) %>%
  mean_qi(b_intercept = b_regionB + b_intercept ) %>%
  mutate("region" = "B")

regularized_df <- rbind(A_reg, B_reg) %>%
  rename(condition_mean = "b_intercept") %>%
  add_column(model = "regularized") %>%
  mutate(condition_mean = condition_mean) %>%
  mutate(.lower = .lower) %>%
  mutate(.upper = .upper )




model_df <- rbind(unregularized_df, regularized_df)
```


```{r}
model_df %>%   
  ggplot(aes(y = condition_mean, 
             x = region, ymin = .lower, ymax = .upper, color = model)) +
  geom_pointrange()

```

Change original data

```{r}

A_shift <- model_df$condition_mean[1] - model_df$condition_mean[3]

B_shift <- model_df$condition_mean[2] - model_df$condition_mean[4]

regularized_sampled_normal <- 
  sampled_normal %>% 
  mutate(profit = ifelse(region == "A", profit - A_shift, profit - B_shift))

```

```{r}
reg_and_unreg <-dplyr::bind_rows(
  list(unregularized=sampled_normal,
       regularized=regularized_sampled_normal), .id = 'source')

reg_and_unreg %>%
  ggplot(aes(x = region, y = profit, color = source)) + 
  geom_point() + 
  geom_pointrange(data = model_df, 
                  mapping = aes(y = condition_mean, 
             x = region, ymin = .lower, ymax = .upper, color = model), position = 
               position_nudge(x = 0.1))
```

## Opaque regularization


```{r}
reg_and_unreg %>%
  filter(source == "regularized") %>%
  ggplot(aes(x = region, y = profit, color = source)) + 
  geom_point() + 
  geom_pointrange(data = model_df[model_df$model == "regularized",], 
                  mapping = aes(y = condition_mean, 
             x = region, ymin = .lower, ymax = .upper, color = model), position = 
               position_nudge(x = 0.1))
```




## Beneficial distortion

Zu tun

# Correlation

Multivar gaussian

https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/mvrnorm.html

positive correlation

```{r}
Sigma_pos <- matrix(c(10,3,3,2),2,2)
mvn_df <- data.frame(mvrnorm(n = 20, c(20, 10), Sigma_pos))
names(mvn_df) <- c("profit", "time")
mvn_df$profit <- mvn_df$profit 

ggplot(mvn_df) + geom_point(aes(profit, time))
```

negative correlation

```{r}
Sigma_pos <- matrix(c(10,-3,3,2),2,2)
mvn_df <- data.frame(mvrnorm(n = 20, c(20, 10), Sigma_pos))
names(mvn_df) <- c("profit", "time")
mvn_df$profit <- mvn_df$profit * 1000

ggplot(mvn_df) + geom_point(aes(profit, time))
```

no correlation

```{r}
Sigma_pos <- matrix(c(10,0 ,0,2),2,2)
mvn_df <- data.frame(mvrnorm(n = 20, c(20, 10), Sigma_pos))
names(mvn_df) <- c("profit", "time")
mvn_df$profit <- mvn_df$profit * 1000

ggplot(mvn_df) + geom_point(aes(profit, time))
```


TODO: transform one variable to uniform or something

- calculate $\mu$ and $\sigma$ for the marginal Gaussian
- get quantiles 
- get X values from another CDF with the quantiles 


generate a bunch of them

```{r}
n_samples <- 4

mvn_samples_df <- data.frame(matrix(nrow = 0, ncol = 3)) # bivariate + sample No.
for (i in seq_len(n_samples)){
  mvn_df <- data.frame(mvrnorm(n = n_obs, rep(0, 2), Sigma_pos))
  mvn_df$sample <- i 
  mvn_samples_df <- rbind(mvn_samples_df, mvn_df)
}

```

```{r}
# ggplot(mvn_samples_df) + 
#   geom_point(aes(X2,X1))  +
#   transition_time(sample) +
#   ease_aes('linear')
```

```{r}

```



# ------- Data semantics

TODO: change based on the decision-making task



- [x] beta distributions
- [x] power curve?
- [x] bimodal
- [x] uniform
- [x] multivariate normal/gaussian
	- [ ] take marginal 


## Beta

Beta parameters from https://en.wikipedia.org/wiki/Beta_distribution

```{r}
a1 <- 2
b1 <- 5

a2 <- 2
b2 <- 2

beta_1 <- rbeta(n_obs, a1, b1)
beta_2 <- rbeta(n_obs, a2, b2)
```

```{r}
plot_df <- melt(data.frame(beta_1, beta_2))
ggplot(plot_df) + geom_violin(aes(x = variable, y = value) )
```

### Comparison

```{r}
beta_sample1 <- rbeta(1, a1, b1)
beta_sample2 <- rbeta(1, a2, b2)
beta_compare_df <- data.frame(value = c(beta_sample1, beta_sample2), condition=c("beta_1", "beta_2"))

ggplot(beta_compare_df) + 
  geom_violin(data=plot_df, aes(x = variable, y = value) ) + 
  geom_bar(aes(condition, value, alpha = 0.5), stat="identity") + 
  ylim(c(0,1)) + NULL

```


## Power curve

Not sure what powercurves are but https://www.rdocumentation.org/packages/poweRlaw/versions/0.70.2/topics/dpldis

```{r}
# from documentation example

xmin <- 1
alpha <- 2
x <- xmin:n_obs
power_curve <- rpldis(x, xmin, alpha)
pc_df <- data.frame(power_curve)

```


```{r}
ggplot(pc_df) + geom_density(aes(power_curve))
```




## Bimodal

Just doing two gaussians: https://stats.stackexchange.com/questions/70855/generating-random-variables-from-a-mixture-of-normal-distributions

```{r}
components <- sample(1:2, prob = c(.4, .6), size = n_obs, replace = TRUE)
mus <- c(0, 2) 
sds <- c(1, 1)
bimodal <- rnorm(n = n_obs, mus[components],sd=sds[components])
bi_df <- data.frame(bimodal)
```

```{r}
ggplot(bi_df) + geom_density(aes(bimodal))
```

```{r}
ggplot(bi_df) +
  geom_histogram(aes(bimodal), binwidth = 1)
```



## uniform

```{r}
uniform_1 <- runif(n = n_obs)
```




